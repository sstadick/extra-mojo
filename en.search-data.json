{"/ExtraMojo/ExtraMojo/":{"data":{"extramojo#\u003ccode\u003eExtraMojo\u003c/code\u003e":"Mojo package ü°≠\nExtraMojo","packages#Packages":" bstr: String-like operations on List[UInt8] and Span[UInt8]. cli: The cli module contains functionality for creating and using command line applications. io: IO. regex: An extremely simple regex implementation. stats: Basic stats. utils: Utilities that don‚Äôt fit nicely elsewhere. "},"title":"ExtraMojo"},"/ExtraMojo/ExtraMojo/bstr/":{"data":{"bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo package ü°≠\nbstrString-like operations on List[UInt8] and Span[UInt8].","modules#Modules":" bstr memchr: Fast memchr implementations. ","references#References":" Rust bstr "},"title":"bstr"},"/ExtraMojo/ExtraMojo/bstr/bstr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) CAPITAL_A = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"A\"))) CAPITAL_Z = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"Z\"))) LOWER_A = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"a\"))) LOWER_Z = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"z\"))) ASCII_CASE_MASK = SIMD(32) ZERO = SIMD(0) ","bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo module ü°≠\nbstr","functions#Functions":" find_chr_all_occurrences is_ascii_uppercase is_ascii_lowercase to_ascii_lowercase to_ascii_uppercase find ","structs#Structs":" SplitIterator: Get an iterator the yields the splits from the input to_split string. "},"title":"bstr"},"/ExtraMojo/ExtraMojo/bstr/bstr/SplitIterator/":{"data":{"fields#Fields":" inner (Span[SIMD[uint8, 1], origin]) split_on (SIMD[uint8, 1]) current (Int) len (Int) next_split (Optional[_StartEnd]) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, to_split: Span[SIMD[uint8, 1], origin], split_on: SIMD[uint8, 1]) Details Args:\nto_split (Span[SIMD[uint8, 1], origin]) split_on (SIMD[uint8, 1]) self (Self) Returns:\nSelf\n__iter__ fn __iter__(self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Details Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Details Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e Span[SIMD[uint8, 1], origin] Details Args:\nself (Self) Returns:\nSpan[SIMD[uint8, 1], origin]\npeek fn peek(self) -\u003e Optional[Span[SIMD[uint8, 1], origin]] Peek ahead at the next split result. Args:\nself (Self) Returns:\nOptional[Span[SIMD[uint8, 1], origin]]","parameters#Parameters":" is_mutable (Bool) origin (Origin[is_mutable]) ","splititerator#\u003ccode\u003eSplitIterator\u003c/code\u003e":"Mojo struct ü°≠\nSplitIterator @memory_only struct SplitIterator[is_mutable: Bool, //, origin: Origin[is_mutable]] Get an iterator the yields the splits from the input `to_split` string. TODO: these test run fine in the test module, but not in doctests. ``` from testing import assert_equal from ExtraMojo.bstr.bstr import SplitIterator var input = \"ABCD\tEFGH\tIJKL MNOP\".as_bytes() var expected = List( ‚ÄúABCD‚Äù.as_bytes(), ‚ÄúEFGH‚Äù.as_bytes(), ‚ÄúIJKL MNOP‚Äù.as_bytes() ) var output = ListSpan[UInt8, StaticConstantOrigin] for value in SplitIterator(input, ord(\"\t‚Äú)): output.append(value) for i in range(len(expected)): assert_equal(StringSlice(unsafe_from_utf8=output[i]), StringSlice(unsafe_from_utf8=expected[i])) ```\n``` from collections.string.string_slice import StringSlice from memory import Span from testing import assert_equal from ExtraMojo.bstr.bstr import SplitIterator var input = \"ABCD\tEFGH\tIJKL MNOP‚Äù.as_bytes() var expected = List( ‚ÄúABCD‚Äù.as_bytes(), ‚ÄúEFGH‚Äù.as_bytes(), ‚ÄúIJKL MNOP‚Äù.as_bytes() ) var iter = SplitIterator(input, ord(\"\t‚Äú)) var first = iter.next() var peek = iter.peek() var second = iter.next() assert_equal(StringSlice(unsafe_from_utf8=peek.value()), StringSlice(unsafe_from_utf8=second)) assert_equal(StringSlice(unsafe_from_utf8=first), StringSlice(unsafe_from_utf8=expected[0])) assert_equal(StringSlice(unsafe_from_utf8=second), StringSlice(unsafe_from_utf8=expected[1])) ```"},"title":"SplitIterator"},"/ExtraMojo/ExtraMojo/bstr/bstr/find/":{"data":{"find#\u003ccode\u003efind\u003c/code\u003e":"Mojo function ü°≠\nfind ‚ûï¬† ‚ûñ fn find(haystack: Span[SIMD[uint8, 1], origin], needle: Span[SIMD[uint8, 1], origin]) -\u003e Optional[Int] Look for the substring needle in the haystack. This is not a terribly smart find implementation. It will use memchr to find occurrences of the first byte in the needle, it then checks the subsequent bytes to see if they match the rest of the needle.\nfrom testing import assert_equal from ExtraMojo.bstr.bstr import find var haystack = \"ABCDEFGhijklmnop\".as_bytes() var expected = 4 var answer = find(haystack, \"EFG\".as_bytes()).value() assert_equal(answer, expected) Args:\nhaystack (Span[SIMD[uint8, 1], origin]): The bytes to be searched for the needle. needle (Span[SIMD[uint8, 1], origin]): The bytes to search for in the haystack. Returns:\nOptional[Int]: Index of the start of the first occurrence of needle."},"title":"find"},"/ExtraMojo/ExtraMojo/bstr/bstr/find_chr_all_occurrences/":{"data":{"find_chr_all_occurrences#\u003ccode\u003efind_chr_all_occurrences\u003c/code\u003e":"Mojo function ü°≠\nfind_chr_all_occurrences ‚ûï¬† ‚ûñ fn find_chr_all_occurrences(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1]) -\u003e List[Int] Find all the occurrences of chr in the input buffer. from testing import assert_equal from ExtraMojo.bstr.bstr import find_chr_all_occurrences var haystack = \"ATCGACCATCGAGATCATGTTTCAT\" var expected = List(2, 5, 6, 9, 15, 22) assert_equal(find_chr_all_occurrences(haystack.as_bytes(), ord(\"C\")), expected) Args:\nhaystack (Span[SIMD[uint8, 1], origin]) chr (SIMD[uint8, 1]) Returns:\nList[Int]"},"title":"find_chr_all_occurrences"},"/ExtraMojo/ExtraMojo/bstr/bstr/is_ascii_lowercase/":{"data":{"is_ascii_lowercase#\u003ccode\u003eis_ascii_lowercase\u003c/code\u003e":"Mojo function ü°≠\nis_ascii_lowercase ‚ûï¬† ‚ûñ fn is_ascii_lowercase(value: SIMD[uint8, 1]) -\u003e Bool Check if a byte is ASCII lowercase. from testing import assert_true, assert_false from ExtraMojo.bstr.bstr import is_ascii_lowercase for ascii_letter in range(ord(\"A\"), ord(\"Z\")+1): assert_false(is_ascii_lowercase(ascii_letter)) for ascii_letter in range(ord(\"a\"), ord(\"z\")+1): assert_true(is_ascii_lowercase(ascii_letter)) assert_false(is_ascii_lowercase(0)) Args:\nvalue (SIMD[uint8, 1]) Returns:\nBool"},"title":"is_ascii_lowercase"},"/ExtraMojo/ExtraMojo/bstr/bstr/is_ascii_uppercase/":{"data":{"is_ascii_uppercase#\u003ccode\u003eis_ascii_uppercase\u003c/code\u003e":"Mojo function ü°≠\nis_ascii_uppercase ‚ûï¬† ‚ûñ fn is_ascii_uppercase(value: SIMD[uint8, 1]) -\u003e Bool Check if a byte is ASCII uppercase. from testing import assert_true, assert_false from ExtraMojo.bstr.bstr import is_ascii_uppercase for ascii_letter in range(ord(\"A\"), ord(\"Z\")+1): assert_true(is_ascii_uppercase(ascii_letter)) for ascii_letter in range(ord(\"a\"), ord(\"z\")+1): assert_false(is_ascii_uppercase(ascii_letter)) assert_false(is_ascii_uppercase(0)) Args:\nvalue (SIMD[uint8, 1]) Returns:\nBool"},"title":"is_ascii_uppercase"},"/ExtraMojo/ExtraMojo/bstr/bstr/to_ascii_lowercase/":{"data":{"to_ascii_lowercase#\u003ccode\u003eto_ascii_lowercase\u003c/code\u003e":"Mojo function ü°≠\nto_ascii_lowercase ‚ûï¬† ‚ûñ fn to_ascii_lowercase(mut buffer: List[SIMD[uint8, 1], hint_trivial_type]) Lowercase all ascii a-zA-Z characters. from testing import assert_equal from ExtraMojo.bstr.bstr import to_ascii_lowercase var test = List(\"ABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZ\".as_bytes()) var expected = List(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\".as_bytes()) to_ascii_lowercase(test) assert_equal(test, expected) Args:\nbuffer (List[SIMD[uint8, 1], hint_trivial_type]) "},"title":"to_ascii_lowercase"},"/ExtraMojo/ExtraMojo/bstr/bstr/to_ascii_uppercase/":{"data":{"to_ascii_uppercase#\u003ccode\u003eto_ascii_uppercase\u003c/code\u003e":"Mojo function ü°≠\nto_ascii_uppercase ‚ûï¬† ‚ûñ fn to_ascii_uppercase(mut buffer: List[SIMD[uint8, 1], hint_trivial_type]) Uppercase all ascii a-zA-Z characters. from testing import assert_equal from ExtraMojo.bstr.bstr import to_ascii_uppercase var test = List(\"ABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZ\".as_bytes()) var expected = List(\"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\".as_bytes()) to_ascii_uppercase(test) assert_equal(test, expected) Args:\nbuffer (List[SIMD[uint8, 1], hint_trivial_type]) "},"title":"to_ascii_uppercase"},"/ExtraMojo/ExtraMojo/bstr/memchr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) LOOP_SIZE = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()).__mul__(4) ","functions#Functions":" memchr memchr_wide ","memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo module ü°≠\nmemchrFast memchr implementations.\nThere are two here, memchr and memchr_wide. memchr_wide will do more comparisons at once, but needs to do more loading first. If you know you have some distance between needles, then it should be faster. memchr is just vanilla memchr."},"title":"memchr"},"/ExtraMojo/ExtraMojo/bstr/memchr/memchr/":{"data":{"memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo function ü°≠\nmemchr ‚ûï¬† ‚ûñ fn memchr(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1], start: Int = 0) -\u003e Int Function to find the next occurrence of character. from memory import Span from testing import assert_equal from ExtraMojo.bstr.memchr import memchr assert_equal(memchr(\"enlivened,unleavened,Arnulfo's,Unilever's,unloved|Anouilh,analogue,analogy\".as_bytes(), ord(\"|\")), 49) Args:\nhaystack (Span[SIMD[uint8, 1], origin]): The bytes to search for the chr. chr (SIMD[uint8, 1]): The byte to search for. start (Int): The starting point to begin the search in haystack. Returns:\nInt: The index of the found character, or -1 if not found."},"title":"memchr"},"/ExtraMojo/ExtraMojo/bstr/memchr/memchr_wide/":{"data":{"memchr_wide#\u003ccode\u003ememchr_wide\u003c/code\u003e":"Mojo function ü°≠\nmemchr_wide ‚ûï¬† ‚ûñ fn memchr_wide(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1], start: Int = 0) -\u003e Int Function to find the next occurrence of character. This function does more unrolling and will be faster if the search if over longer distances. If in doubt use memchr.\nfrom memory import Span from testing import assert_equal from ExtraMojo.bstr.memchr import memchr_wide assert_equal(memchr_wide(\"enlivened,unleavened,Arnulfo's,Unilever's,unloved|Anouilh,analogue,analogy\".as_bytes(), ord(\"|\")), 49) Args:\nhaystack (Span[SIMD[uint8, 1], origin]): The bytes to search for the chr. chr (SIMD[uint8, 1]): The byte to search for. start (Int): The starting point to begin the search in haystack. Returns:\nInt: The index of the found character, or -1 if not found."},"title":"memchr_wide"},"/ExtraMojo/ExtraMojo/cli/":{"data":{"cli#\u003ccode\u003ecli\u003c/code\u003e":"Mojo package ü°≠\ncliThe cli module contains functionality for creating and using command line applications.","modules#Modules":" parser: A very basic CLI Opt Parser. "},"title":"cli"},"/ExtraMojo/ExtraMojo/cli/parser/":{"data":{"parser#\u003ccode\u003eparser\u003c/code\u003e":"Mojo module ü°≠\nparserA very basic CLI Opt Parser.\nfrom testing import assert_equal, assert_true from ExtraMojo.cli.parser import OptParser, OptConfig, OptKind var args = List(String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\")) var program_name = \"example\" var parser = OptParser(name=\"example\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) # Note, a user would call parser.parse_sys_args() var opts = parser.parse_args(args) assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) ","structs#Structs":" OptKind: The viable types for an option to have. OptValue: When an option is parsed, it‚Äôs stored as an OptValue. OptConfig: Create an option to be added to the OptParser. ParsedOpts: The parsed CLI options. Access your values with ParsedOpts.get_string(), ParsedOpts.get_int(), etc. OptParser: [OptParser] will try to parse your long-form CLI options. Subcommand: A subcommand. SubcommandParser: Subcommands are created by passing in the command, and an OptParser. "},"title":"parser"},"/ExtraMojo/ExtraMojo/cli/parser/OptConfig/":{"data":{"fields#Fields":" long_name (String): Required long name of, this will be used as the cli value as --long_name. default_value (Optional[String]): If there is one, the Stringified deafult value. This will be parsed via OptKind. value_kind (OptKind): The type of the value for this option. is_flag (Bool): If it‚Äôs a flag, then it‚Äôs value_kind needs to be Bool. description (String): Long for description, for best results, don‚Äôt add a newline. ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned long_name: String, value_kind: OptKind, *, is_flag: Bool = False, owned description: String = String(\"\"), owned default_value: Optional[String] = Optional(None)) Details Args:\nlong_name (String) value_kind (OptKind) is_flag (Bool) description (String) default_value (Optional[String]) self (Self) Returns:\nSelf\nRaises:","optconfig#\u003ccode\u003eOptConfig\u003c/code\u003e":"Mojo struct ü°≠\nOptConfig @memory_only struct OptConfig Create an option to be added to the OptParser."},"title":"OptConfig"},"/ExtraMojo/ExtraMojo/cli/parser/OptKind/":{"data":{"aliases#Aliases":" StringLike = OptKind(SIMD(0)) IntLike = OptKind(SIMD(1)) FloatLike = OptKind(SIMD(2)) BoolLike = OptKind(SIMD(3)) ","fields#Fields":" value (SIMD[uint8, 1]) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, Stringable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, value: SIMD[uint8, 1]) Details Args:\nvalue (SIMD[uint8, 1]) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__str__ fn __str__(self) -\u003e String Details Args:\nself (Self) Returns:\nString","optkind#\u003ccode\u003eOptKind\u003c/code\u003e":"Mojo struct ü°≠\nOptKind @memory_only struct OptKind The viable types for an option to have."},"title":"OptKind"},"/ExtraMojo/ExtraMojo/cli/parser/OptParser/":{"data":{"fields#Fields":" options (Dict[String, OptConfig]): The options this will attempt to parse. program_description (String): The description of the program, to be used in the help message. program_name (String): Your programs name, to be used in the help message. ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, *, name: String, description: String = String(\"\")) Details Args:\nname (String) description (String) self (Self) Returns:\nSelf\nRaises:\nadd_opt fn add_opt(mut self, owned arg: OptConfig) Add an [OptConfig]. Args:\nself (Self) arg (OptConfig) help_msg fn help_msg(self) -\u003e String Get the help message string based on the currently added options. Args:\nself (Self) Returns:\nString\nparse_sys_args fn parse_sys_args(mut self) -\u003e ParsedOpts Parse the arguments from sys.argv(). Args:\nself (Self) Returns:\nParsedOpts\nRaises:\nparse_args fn parse_args(self, args: List[String]) -\u003e ParsedOpts Parse the arguments passed in via args. Args:\nself (Self) args (List[String]) Returns:\nParsedOpts\nRaises:","optparser#\u003ccode\u003eOptParser\u003c/code\u003e":"Mojo struct ü°≠\nOptParser @memory_only struct OptParser [OptParser] will try to parse your long-form CLI options."},"title":"OptParser"},"/ExtraMojo/ExtraMojo/cli/parser/OptValue/":{"data":{"fields#Fields":" kind (OptKind) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, str_value: String = String(\"\")) Details Args:\nstr_value (String) self (Self) Returns:\nSelf\nfn __init__(out self, int_value: Int = 0) Details Args:\nint_value (Int) self (Self) Returns:\nSelf\nfn __init__(out self, float_value: SIMD[float64, 1] = SIMD(#kgen.float_literal\u003c0|1\u003e)) Details Args:\nfloat_value (SIMD[float64, 1]) self (Self) Returns:\nSelf\nfn __init__(out self, bool_value: Bool = False) Details Args:\nbool_value (Bool) self (Self) Returns:\nSelf\nget_string fn get_string(self) -\u003e Optional[String] Details Args:\nself (Self) Returns:\nOptional[String]\nget_int fn get_int(self) -\u003e Optional[Int] Details Args:\nself (Self) Returns:\nOptional[Int]\nget_float fn get_float(self) -\u003e Optional[SIMD[float64, 1]] Details Args:\nself (Self) Returns:\nOptional[SIMD[float64, 1]]\nget_bool fn get_bool(self) -\u003e Optional[Bool] Details Args:\nself (Self) Returns:\nOptional[Bool]\nparse_string @staticmethod fn parse_string(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nparse_int @staticmethod fn parse_int(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_float @staticmethod fn parse_float(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_bool @staticmethod fn parse_bool(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_kind @staticmethod fn parse_kind(kind: OptKind, value: String) -\u003e Self Parse the string based on the value of OptKind. Args:\nkind (OptKind) value (String) Returns:\nSelf\nRaises:","optvalue#\u003ccode\u003eOptValue\u003c/code\u003e":"Mojo struct ü°≠\nOptValue @memory_only struct OptValue When an option is parsed, it‚Äôs stored as an OptValue.\nTo get concrete values out of the ParsedOpts prefer to use the ParsedOpts.get_\u003ctype\u003e() methods."},"title":"OptValue"},"/ExtraMojo/ExtraMojo/cli/parser/ParsedOpts/":{"data":{"fields#Fields":" options (Dict[String, OptValue]) args (List[String]) help_msg (String) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned help_msg: String = String(\"\")) Details Args:\nhelp_msg (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(ref self) -\u003e Pointer[String, self_is_origin.help_msg] Get a nicely formatted help string. Args:\nself (Self) Returns:\nPointer[String, self_is_origin.help_msg]\nget_string fn get_string(self, key: String) -\u003e String Try to get the option specified with the given key as a String. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nString\nRaises:\nget_int fn get_int(self, key: String) -\u003e Int Try to get the option specified with the given key as an Int. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nInt\nRaises:\nget_float fn get_float(self, key: String) -\u003e SIMD[float64, 1] Try to get the option specified with the given key as a Float64. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nSIMD[float64, 1]\nRaises:\nget_bool fn get_bool(self, key: String) -\u003e Bool Try to get the option specified with the given key as a Bool. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nBool\nRaises:","parsedopts#\u003ccode\u003eParsedOpts\u003c/code\u003e":"Mojo struct ü°≠\nParsedOpts @memory_only struct ParsedOpts The parsed CLI options. Access your values with ParsedOpts.get_string(), ParsedOpts.get_int(), etc.\nAccess CLI arguments from ParsedOpts.args. Get the help message with ParsedOpts.get_help_message.\nNote that there is an automatic help flag added to your options, it can be overridden by another option with that same name. The input args are first scanned for ‚Äú‚Äìhelp‚Äù and if that is found the parser will exit early, returning the parsed value of the ‚Äú‚Äìhelp‚Äù flag (or option if you have overridden it). It is up to the user to check for the ‚Äúhelp‚Äù option being set and print the help message."},"title":"ParsedOpts"},"/ExtraMojo/ExtraMojo/cli/parser/Subcommand/":{"data":{"fields#Fields":" parser (OptParser) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Hashable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned name: String, owned parser: OptParser) Details Args:\nname (String) parser (OptParser) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__hash__ fn __hash__(self) -\u003e UInt Details Args:\nself (Self) Returns:\nUInt","subcommand#\u003ccode\u003eSubcommand\u003c/code\u003e":"Mojo struct ü°≠\nSubcommand @memory_only struct Subcommand A subcommand.\nThe name of the subcommand is the OptParser.name. The name of the subcommand will be checked against the first value in the input args. The help message will display the program description for the OptParser that is associated with this subcommand."},"title":"Subcommand"},"/ExtraMojo/ExtraMojo/cli/parser/SubcommandParser/":{"data":{"fields#Fields":" commands (Dict[String, Subcommand]) description (String) name (String) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, *, owned name: String, owned description: String = String(\"\")) Details Args:\nname (String) description (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(self) -\u003e String Create the help message for the subcommands. Args:\nself (Self) Returns:\nString\nRaises:\nadd_command fn add_command(mut self, command: Subcommand) Add a subcommand. Args:\nself (Self) command (Subcommand) parse_args fn parse_args(self, args: List[String]) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the input args, expecting a subcommand. Args:\nself (Self) args (List[String]) Returns:\nOptional[Tuple[String, ParsedOpts]]\nRaises:\nparse_sys_args fn parse_sys_args(self) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the sys.argv() list. Args:\nself (Self) Returns:\nOptional[Tuple[String, ParsedOpts]]\nRaises:","subcommandparser#\u003ccode\u003eSubcommandParser\u003c/code\u003e":"Mojo struct ü°≠\nSubcommandParser @memory_only struct SubcommandParser Subcommands are created by passing in the command, and an OptParser.\nThe parser is for the options for the subcommand.\nfrom testing import assert_equal, assert_true from ExtraMojo.cli.parser import OptParser, OptConfig, OptKind, SubcommandParser, Subcommand var args = List(String(\"do-work\"), String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\")) var program_name = \"example\" var parser = OptParser(name=\"do-work\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) var cmd = Subcommand(parser) # uses the name from the passed in parser var cmd_parser = SubcommandParser(name=String(\"cool-program\"), description=\"Do some cool stuff.\") cmd_parser.add_command(cmd) # Note, a user would call parser.parse_sys_args() var cmd_and_opts = cmd_parser.parse_args(args) if not cmd_and_opts: print(cmd_parser.get_help_message()) parsed_cmd, opts = cmd_and_opts.value() if parsed_cmd == cmd.parser.program_name: assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) "},"title":"SubcommandParser"},"/ExtraMojo/ExtraMojo/io/":{"data":{"io#\u003ccode\u003eio\u003c/code\u003e":"Mojo package ü°≠\nioIO.","modules#Modules":" buffered: Buffered reading and writing. delimited: Working with simple delimited text. "},"title":"io"},"/ExtraMojo/ExtraMojo/io/buffered/":{"data":{"aliases#Aliases":" NEW_LINE = 10 SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) BUF_SIZE = 131072 ","buffered#\u003ccode\u003ebuffered\u003c/code\u003e":"Mojo module ü°≠\nbufferedBuffered reading and writing.","examples#Examples":"BufferedReader:\nfrom testing import assert_equal from ExtraMojo.io.buffered import BufferedReader fn test_read_until(file: String, expected_lines: List[String]) raises: var buffer_capacities = List(10, 100, 200, 500) for cap in buffer_capacities: var fh = open(file, \"r\") var reader = BufferedReader(fh^, buffer_capacity=cap[]) var buffer = List[UInt8]() var counter = 0 while reader.read_until(buffer) != 0: assert_equal(List(expected_lines[counter].as_bytes()), buffer) counter += 1 assert_equal(counter, len(expected_lines)) print(\"Successful read_until with buffer capacity of {}\".format(cap[])) BufferedWriter:\nfrom ExtraMojo.io.buffered import BufferedWriter fn test_buffered_writer(file: String, expected_lines: List[String]) raises: var fh = BufferedWriter(open(String(file), \"w\"), buffer_capacity=128) for i in range(len(expected_lines)): fh.write_bytes(expected_lines[i].as_bytes()) fh.write_bytes(\" \".as_bytes()) fh.flush() fh.close() test_read_until(String(file), expected_lines) ","functions#Functions":" read_lines for_each_line get_next_line ","structs#Structs":" BufferedReader: BufferedReader for readying lines and bytes from a file in a buffered way. BufferedWriter: A BufferedWriter. "},"title":"buffered"},"/ExtraMojo/ExtraMojo/io/buffered/BufferedReader/":{"data":{"bufferedreader#\u003ccode\u003eBufferedReader\u003c/code\u003e":"Mojo struct ü°≠\nBufferedReader @memory_only struct BufferedReader BufferedReader for readying lines and bytes from a file in a buffered way.","example#Example":" from ExtraMojo.io.buffered import BufferedReader fn read_bytes(read file: String) raises -\u003e List[UInt8]: var fh = open(file, \"r\") var reader = BufferedReader(fh^, buffer_capacity=50) var buffer = List[UInt8](capacity=125) for _ in range(0, 125): buffer.append(0) var found_file = List[UInt8]() # Read bytes from the buf reader, copy to found var bytes_read = 0 while True: bytes_read = reader.read_bytes(buffer) if bytes_read == 0: break found_file.extend(buffer[0:bytes_read]) return found_file ","fields#Fields":" fh (FileHandle): The internal filehandle to read from. buffer (UnsafePointer[SIMD[uint8, 1]]): The internal buffer. file_offset (Int): Current offset into the file. buffer_offset (Int): Current offset into the buffer. buffer_capacity (Int): Total capacity of the buffer. buffer_len (Int): Total filled capacity of the buffer. ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned fh: FileHandle, buffer_capacity: Int = 131072) Create a BufferedReader. Args:\nfh (FileHandle): The filehandle to read from. buffer_capacity (Int): The size of the buffer to use. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(owned self) Details Args:\nself (Self) __enter__ fn __enter__(owned self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nread_bytes fn read_bytes(mut self, mut buffer: List[SIMD[uint8, 1]]) -\u003e Int Read up to len(buffer) bytes. Args:\nself (Self) buffer (List[SIMD[uint8, 1]]): The buffer to read into. The len of the buffer determines how many bytes will be read. Returns:\nInt: This returns the number of bytes read. If the number of bytes read is less then len(buffer) then EOF has been reached.\nRaises:\nread_until fn read_until(mut self, mut buffer: List[SIMD[uint8, 1]], char: UInt = 10) -\u003e Int Fill the given line_buffer until the given char is hit, or EOF. Args:\nself (Self) buffer (List[SIMD[uint8, 1]]): The buffer to filled with any bytes found before char is hit. char (UInt): The character to use as the terminator. Returns:\nInt: The number of bytes read.\nRaises:"},"title":"BufferedReader"},"/ExtraMojo/ExtraMojo/io/buffered/BufferedWriter/":{"data":{"bufferedwriter#\u003ccode\u003eBufferedWriter\u003c/code\u003e":"Mojo struct ü°≠\nBufferedWriter @memory_only struct BufferedWriter[W: MovableWriter] A BufferedWriter.\n## Example ```mojo from ExtraMojo.io.buffered import BufferedWriter fn write_to_file(read file: String, read expected_lines: List[String]) raises: var fh = BufferedWriter(open(String(file), \"w\"), buffer_capacity=128) for i in range(len(expected_lines)): fh.write_bytes(expected_lines[i].as_bytes()) fh.write_bytes(\" ‚Äú.as_bytes()) fh.flush() fh.close() ```","fields#Fields":" inner (W): The inner file handle to write to. buffer (List[SIMD[uint8, 1]]): The inner buffer. buffer_capacity (Int): The capacity of the inner buffer. buffer_len (Int): The number of bytes currently stored in the inner buffer. ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility, Writer","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned writer: W, buffer_capacity: Int = 131072) Create a BufferedReader. Args:\nwriter (W): The writer to write to. buffer_capacity (Int): The capacity of the inner buffer to use. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(owned self) Details Args:\nself (Self) __enter__ fn __enter__(owned self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nclose fn close(mut self) Details Args:\nself (Self) Raises:\nwrite_bytes fn write_bytes(mut self, bytes: Span[SIMD[uint8, 1], origin]) Write bytes to this writer. Args:\nself (Self) bytes (Span[SIMD[uint8, 1], origin]): The bytes that will be written to the underlying buffer. write fn write[*Ts: Writable](mut self, *args: *Ts) Implement write. Parameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts): Any Writable values that will be written to the writer. flush fn flush(mut self) Write any remaining bytes in the current buffer, then clear the buffer. Args:\nself (Self) ","parameters#Parameters":" W (MovableWriter) "},"title":"BufferedWriter"},"/ExtraMojo/ExtraMojo/io/buffered/for_each_line/":{"data":{"for_each_line#\u003ccode\u003efor_each_line\u003c/code\u003e":"Mojo function ü°≠\nfor_each_line ‚ûï¬† ‚ûñ fn for_each_line[func: fn[Bool, Origin[$0]](Span[SIMD[uint8, 1], $1], Int, Int) capturing -\u003e None](path: String, buf_size: Int = 131072) Call the provided callback on each line. The callback will be given a buffer, and the [start, end) of where the line is in that buffer.\nParameters:\nfunc (fn[Bool, Origin[$0]](Span[SIMD[uint8, 1], $1], Int, Int) capturing -\u003e None): The callback to run for each line. Args:\npath (String): The file path to open and read. buf_size (Int): The size of the buffer to use. Raises:"},"title":"for_each_line"},"/ExtraMojo/ExtraMojo/io/buffered/get_next_line/":{"data":{"get_next_line#\u003ccode\u003eget_next_line\u003c/code\u003e":"Mojo function ü°≠\nget_next_line ‚ûï¬† ‚ûñ fn get_next_line[is_mutable: Bool, //, origin: Origin[$0]](buffer: Span[SIMD[uint8, 1], origin], start: Int) -\u003e Span[SIMD[uint8, 1], origin] Function to get the next line using either SIMD instruction (default) or iteratively. Parameters:\nis_mutable (Bool) origin (Origin[$0]) Args:\nbuffer (Span[SIMD[uint8, 1], origin]): The buffer to search for the next newline character. start (Int): The start position to use inside the buffer. Returns:\nSpan[SIMD[uint8, 1], origin]: A span of bytes from [start, newline)."},"title":"get_next_line"},"/ExtraMojo/ExtraMojo/io/buffered/read_lines/":{"data":{"read_lines#\u003ccode\u003eread_lines\u003c/code\u003e":"Mojo function ü°≠\nread_lines ‚ûï¬† ‚ûñ fn read_lines(path: String, buf_size: Int = 131072) -\u003e List[List[SIMD[uint8, 1]]] Read all the lines in the file and return them as a List of Lists of bytes. Args:\npath (String): The file path to open and read. buf_size (Int): The size of the buffer to use. Returns:\nList[List[SIMD[uint8, 1]]]: A list of lines, where each line is a List[UInt8].\nRaises:"},"title":"read_lines"},"/ExtraMojo/ExtraMojo/io/delimited/":{"data":{"delimited#\u003ccode\u003edelimited\u003c/code\u003e":"Mojo module ü°≠\ndelimitedWorking with simple delimited text.","example#Example":"Compile-time known fields:\nTODO: this should be two different examples, but the doc parser can‚Äôt seem to handle that for this example.\nfrom collections.string import StringSlice from testing import assert_equal from ExtraMojo.bstr.bstr import SplitIterator from ExtraMojo.cli.parser import ParsedOpts from ExtraMojo.io.buffered import ( BufferedReader, BufferedWriter, ) from ExtraMojo.io.delimited import ( DelimReader, FromDelimited, ToDelimited, DelimWriter, ) # ######################################### # Example with compile-time known fields. # ######################################### @value struct SerDerStruct(ToDelimited, FromDelimited): var index: Int var name: String fn write_to_delimited(read self, mut writer: DelimWriter) raises: writer.write_record(self.index, self.name) fn write_header(read self, mut writer: DelimWriter) raises: writer.write_record(\"index\", \"name\") @staticmethod fn from_delimited(mut data: SplitIterator) raises -\u003e Self: var index = Int(StringSlice(unsafe_from_utf8=data.__next__())) var name = String() # String constructor expected nul terminated byte span name.write_bytes(data.__next__()) return Self(index, name) fn test_delim_reader_writer(file: String) raises: var to_write = List[SerDerStruct]() for i in range(0, 1000): to_write.append(SerDerStruct(i, String(\"MyNameIs\" + String(i)))) var writer = DelimWriter( BufferedWriter(open(String(file), \"w\")), delim=\"\t\", write_header=True ) for item in to_write: writer.serialize(item[]) writer.flush() writer.close() var reader = DelimReader[SerDerStruct]( BufferedReader(open(String(file), \"r\")), delim=ord(\"\t\"), has_header=True, ) var count = 0 for item in reader^: assert_equal(to_write[count].index, item.index) assert_equal(to_write[count].name, item.name) count += 1 assert_equal(count, len(to_write)) # ######################################### # Example with dynamic fields. # ######################################### @value struct Score[ truth_lengths_origin: ImmutableOrigin, truth_names_origin: ImmutableOrigin, ](ToDelimited): var assembly_name: String var assembly_length: Int var scores: List[Int32] var truth_lengths: Pointer[List[Int], truth_lengths_origin] var truth_names: Pointer[List[String], truth_names_origin] fn __init__( out self, owned assembly_name: String, assembly_length: Int, owned scores: List[Int32], ref [truth_lengths_origin]truth_lengths: List[Int], ref [truth_names_origin]truth_names: List[String], ): self.assembly_name = assembly_name^ self.assembly_length = assembly_length self.scores = scores^ self.truth_lengths = Pointer.address_of(truth_lengths) self.truth_names = Pointer.address_of(truth_names) fn write_to_delimited(read self, mut writer: DelimWriter) raises: writer.write_field(self.assembly_name, is_last=False) writer.write_field(self.assembly_length, is_last=False) for i in range(0, len(self.scores)): writer.write_field( \"{}/{}\".format(self.scores[i], self.truth_lengths[][i]), is_last=i == len(self.scores) - 1, ) fn write_header(read self, mut writer: DelimWriter) raises: writer.write_field(\"assembly_name\", is_last=False) writer.write_field(\"assembly_length\", is_last=False) for i in range(0, len(self.truth_names[])): writer.write_field( self.truth_names[][i], is_last=i == len(self.truth_names[]) - 1 ) fn run_check_scores(opts: ParsedOpts) raises: var truth_names = List(String(\"A\"), String(\"B\"), String(\"C\")) var truth_lengths = List(125, 2000, 1234) var output_scores_tsv = \"/tmp/out.tsv\" var scores = List( Score(String(\"Assembly1\"), 100, List[Int32](1, 2, 3), truth_lengths, truth_names), Score(String(\"Assembly2\"), 100, List[Int32](100, 2, 3), truth_lengths, truth_names), Score(String(\"Assembly3\"), 100, List[Int32](1, 100, 3), truth_lengths, truth_names), Score(String(\"Assembly4\"), 100, List[Int32](1, 2, 100), truth_lengths, truth_names) ) var out_writer = DelimWriter( BufferedWriter(open(output_scores_tsv, \"w\")), delim=\"\t\", write_header=True, ) for score in scores: out_writer.serialize[ Score[__origin_of(truth_lengths), __origin_of(truth_names)] ](score[]) out_writer.flush() out_writer.close() ","structs#Structs":" DelimReader: Read delimited data that is delimited by a single bytes. DelimWriter: Write delimited data. ","traits#Traits":" FromDelimited: Create an instance of Self from the iterator over Span[UInt8] bytes. ToDelimited "},"title":"delimited"},"/ExtraMojo/ExtraMojo/io/delimited/DelimReader/":{"data":{"delimreader#\u003ccode\u003eDelimReader\u003c/code\u003e":"Mojo struct ü°≠\nDelimReader @memory_only struct DelimReader[RowType: FromDelimited] Read delimited data that is delimited by a single bytes.\nThe RowType must implement FromBytes which is passed an iterator over the split up line.","fields#Fields":" delim (SIMD[uint8, 1]) reader (BufferedReader) next_elem (Optional[RowType]) buffer (List[SIMD[uint8, 1]]) len (Int) has_header (Bool) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned reader: BufferedReader, *, delim: SIMD[uint8, 1], has_header: Bool) Details Args:\nreader (BufferedReader) delim (SIMD[uint8, 1]) has_header (Bool) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Details Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Details Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e RowType Details Args:\nself (Self) Returns:\nRowType\nRaises:\n__iter__ fn __iter__(owned self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf","parameters#Parameters":" RowType (FromDelimited) "},"title":"DelimReader"},"/ExtraMojo/ExtraMojo/io/delimited/DelimWriter/":{"data":{"delimwriter#\u003ccode\u003eDelimWriter\u003c/code\u003e":"Mojo struct ü°≠\nDelimWriter @memory_only struct DelimWriter[W: MovableWriter] Write delimited data.","fields#Fields":" delim (String): The delimiter to use. writer (BufferedWriter[W]): The BufferedWriter to write to. write_header (Bool): Whether or not to write headers. needs_to_write_header (Bool): Whether or not we need to write the headers still. ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, owned writer: BufferedWriter[W], *, owned delim: String, write_header: Bool) Create a DelimWriter. Args:\nwriter (BufferedWriter[W]): The BufferedWriter to write to. delim (String): The delimiter to use. write_header (Bool): Whether or not to write headers. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__enter__ fn __enter__(owned self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nflush fn flush(mut self) Details Args:\nself (Self) close fn close(mut self) Details Args:\nself (Self) Raises:\nwrite_record fn write_record[*Ts: Writable](mut self, *args: *Ts) Write the passed in arguments as a delimited record. Parameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts) Raises:\nwrite_field fn write_field[T: Writable](mut self, column: T, *, is_last: Bool) Write a single field, delimited by the configured delimiter. Parameters:\nT (Writable) Args:\nself (Self) column (T) is_last (Bool) Raises:\nserialize fn serialize[T: ToDelimited](mut self, value: T) Write a struct that implements ToDelimted to the underlying writer. Parameters:\nT (ToDelimited) Args:\nself (Self) value (T) Raises:","parameters#Parameters":" W (MovableWriter) "},"title":"DelimWriter"},"/ExtraMojo/ExtraMojo/io/delimited/FromDelimited/":{"data":{"fromdelimited#\u003ccode\u003eFromDelimited\u003c/code\u003e":"Mojo trait ü°≠\nFromDelimitedCreate an instance of Self from the iterator over Span[UInt8] bytes.","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __copyinit__ @staticmethod fn __copyinit__(out self: _Self, existing: _Self, /) Create a new instance of the value by copying an existing one. Args:\nexisting (_Self): The value to copy. self (_Self) Returns:\n_Self\n__moveinit__ @staticmethod fn __moveinit__(out self: _Self, owned existing: _Self, /) Create a new instance of the value by moving the value of another. Args:\nexisting (_Self): The value to move. self (_Self) Returns:\n_Self\nfrom_delimited @staticmethod fn from_delimited(mut data: SplitIterator[origin]) -\u003e _Self Details Args:\ndata (SplitIterator[origin]) Returns:\n_Self\nRaises:"},"title":"FromDelimited"},"/ExtraMojo/ExtraMojo/io/delimited/ToDelimited/":{"data":{"implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ write_to_delimited fn write_to_delimited(self: _Self, mut writer: DelimWriter[W]) Write self to the passed in writer. This should probably be done with DelimWriter.write_record or a series of DelimWriter.write_field calls.\nArgs:\nself (_Self) writer (DelimWriter[W]) Raises:\nwrite_header fn write_header(self: _Self, mut writer: DelimWriter[W]) Write selfs headers to the passed in writer. This should probably be done with DelimWriter.write_record or a series of DelimWriter.write_field calls.\nArgs:\nself (_Self) writer (DelimWriter[W]) Raises:","todelimited#\u003ccode\u003eToDelimited\u003c/code\u003e":"Mojo trait ü°≠\nToDelimited"},"title":"ToDelimited"},"/ExtraMojo/ExtraMojo/regex/":{"data":{"modules#Modules":" simple_re: A very simple regex implementation in Mojo inspired by Rob Pikes implementation. ","regex#\u003ccode\u003eregex\u003c/code\u003e":"Mojo package ü°≠\nregexAn extremely simple regex implementation."},"title":"regex"},"/ExtraMojo/ExtraMojo/regex/simple_re/":{"data":{"aliases#Aliases":" START_ANCHOR = ord[::Bool,::Origin[$0]](StringSlice(\"^\")) END_ANCHOR = ord[::Bool,::Origin[$0]](StringSlice(\"$\")) DOT = ord[::Bool,::Origin[$0]](StringSlice(\".\")) STAR = ord[::Bool,::Origin[$0]](StringSlice(\"*\")) NULL = 0 ","functions#Functions":" is_match is_match_bytes ","references#References":" https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html ","simple_re#\u003ccode\u003esimple_re\u003c/code\u003e":"Mojo module ü°≠\nsimple_reA very simple regex implementation in Mojo inspired by Rob Pikes implementation."},"title":"simple_re"},"/ExtraMojo/ExtraMojo/regex/simple_re/is_match/":{"data":{"is_match#\u003ccode\u003eis_match\u003c/code\u003e":"Mojo function ü°≠\nis_match ‚ûï¬† ‚ûñ fn is_match(regexp: String, text: String) -\u003e Bool Search for regexp anywhere in text and return true if it matches. from testing import assert_true, assert_false from ExtraMojo.regex.simple_re import is_match var re = \"wha*\" assert_true(is_match(re, \"what am I doing here\")) assert_true(is_match(re, \"whaaaaaaat am I doing here\")) assert_true(is_match(re, \"wht am I doing here\")) assert_false(is_match(re, \"wt am I doing here\")) Args:\nregexp (String): The regular expression to search with. text (String): The text to search. Returns:\nBool: True if the regexp matches the text."},"title":"is_match"},"/ExtraMojo/ExtraMojo/regex/simple_re/is_match_bytes/":{"data":{"is_match_bytes#\u003ccode\u003eis_match_bytes\u003c/code\u003e":"Mojo function ü°≠\nis_match_bytes ‚ûï¬† ‚ûñ fn is_match_bytes(regexp: Span[SIMD[uint8, 1], origin], text: Span[SIMD[uint8, 1], origin]) -\u003e Bool Search for regexp anywhere in text and return true if it matches. from testing import assert_true, assert_false from ExtraMojo.regex.simple_re import is_match_bytes var re = \"^cat\".as_bytes() assert_true(is_match_bytes(re, \"cats of a feather\".as_bytes())) assert_false(is_match_bytes(re, \"bird cats of a cat\".as_bytes())) Args:\nregexp (Span[SIMD[uint8, 1], origin]): The regular expression to search with. text (Span[SIMD[uint8, 1], origin]): The text to search. Returns:\nBool: True if the regexp matches the text."},"title":"is_match_bytes"},"/ExtraMojo/ExtraMojo/stats/":{"data":{"modules#Modules":" sampling: Reservoir sampling on a stream. ","stats#\u003ccode\u003estats\u003c/code\u003e":"Mojo package ü°≠\nstatsBasic stats."},"title":"stats"},"/ExtraMojo/ExtraMojo/stats/sampling/":{"data":{"references#References":" Algorithm R: https://en.wikipedia.org/wiki/Reservoir_sampling ","sampling#\u003ccode\u003esampling\u003c/code\u003e":"Mojo module ü°≠\nsamplingReservoir sampling on a stream.","structs#Structs":" ReservoirSampler: Sample N items from a stream of unknown length. "},"title":"sampling"},"/ExtraMojo/ExtraMojo/stats/sampling/ReservoirSampler/":{"data":{"fields#Fields":" reservoir (List[T]) values_to_collect (Int) seen_values (Int) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, values_to_collect: Int) Details Args:\nvalues_to_collect (Int) self (Self) Returns:\nSelf\ninsert fn insert(mut self, item: T) Add an element. The element will be tested for addition to the reservoir.\nArgs:\nself (Self) item (T) ","parameters#Parameters":" T (CollectionElement) ","reservoirsampler#\u003ccode\u003eReservoirSampler\u003c/code\u003e":"Mojo struct ü°≠\nReservoirSampler @memory_only struct ReservoirSampler[T: CollectionElement] Sample N items from a stream of unknown length.\nSample all the elements, this should retain the order since we always automatically take the first N elements.\nfrom random import seed from testing import assert_equal from ExtraMojo.stats.sampling import ReservoirSampler # Set the global random seed seed(42) var sampler = ReservoirSampler[Int](10) var items = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) for item in items: sampler.insert(item[]) assert_equal(sampler.reservoir, items) Sample only a subset of the input list.\nvar sampler = ReservoirSampler[Int](5) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 5) assert_equal(sampler.reservoir, List(0, 9, 2, 3, 7)) Sample only a single element.\nvar sampler = ReservoirSampler[Int](1) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 1) assert_equal(sampler.reservoir, List(6)) Sample more elements than are in the input stream.\nvar sampler = ReservoirSampler[Int](11) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 10) assert_equal(sampler.reservoir, items) Sample zero elements\nvar sampler = ReservoirSampler[Int](0) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 0) assert_equal(sampler.reservoir, List[Int]()) "},"title":"ReservoirSampler"},"/ExtraMojo/ExtraMojo/utils/":{"data":{"modules#Modules":" ir: Package version of this from @soraros. Linked gist ","utils#\u003ccode\u003eutils\u003c/code\u003e":"Mojo package ü°≠\nutilsUtilities that don‚Äôt fit nicely elsewhere."},"title":"utils"},"/ExtraMojo/ExtraMojo/utils/ir/":{"data":{"functions#Functions":" dump_ir ","ir#\u003ccode\u003eir\u003c/code\u003e":"Mojo module ü°≠\nirPackage version of this from @soraros. Linked gist","structs#Structs":" Setting ","usage#Usage":" from sys.intrinsics import assume from ExtraMojo.utils.ir import dump_ir fn main(): dump_ir[f, \"out1\"](dir=\"./\") dump_ir[g, \"out2\"](dir=\"/tmp\") @export # use `export` so get cleaner names fn f(x: Int) -\u003e Int: assume(0 \u003c= x \u003c 100) return max(1, x * 2) @export fn g(x: Int) -\u003e Int: assume(0 \u003c= x \u003c 100) return x * 2 + Int(x == 0) "},"title":"ir"},"/ExtraMojo/ExtraMojo/utils/ir/Setting/":{"data":{"fields#Fields":" kind (StringLiteral) ext (StringLiteral) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","setting#\u003ccode\u003eSetting\u003c/code\u003e":"Mojo struct ü°≠\nSetting @memory_only struct Setting "},"title":"Setting"},"/ExtraMojo/ExtraMojo/utils/ir/dump_ir/":{"data":{"dump_ir#\u003ccode\u003edump_ir\u003c/code\u003e":"Mojo function ü°≠\ndump_ir ‚ûï¬† ‚ûñ fn dump_ir[Fn: AnyTrivialRegType, //, f: $0, name: StringLiteral = \"out\"](dir: String = String(\"/tmp\")) Details Parameters:\nFn (AnyTrivialRegType) f ($0) name (StringLiteral) Args:\ndir (String) "},"title":"dump_ir"}}